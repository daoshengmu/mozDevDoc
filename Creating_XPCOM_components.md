## XPCOM
https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Creating_components/An_Overview_of_XPCOM

## About this article
This is the implementation note of [Creating XPCOM components](#XPCOM). 

<!-- More -->

## Prerequisite

Before implementing XPCOM components, 
you need to get the firefox source code, 
which is known as **mozilla-central**, from Mercurial or Git.
The path of mozilla-central is denoted by **MOZ_CEN** from here.

- MDN : https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Source_Code/Mercurial
- Mercurial Menual : https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Source_Code/Mercurial
- Mercurial : https://hg.mozilla.org/mozilla-central/
- Git : https://github.com/mozilla/mozilla-central


## Terminology

- MOZ_CEN: the path of mozilla-central project


## Concept


## Playing the existing XPCOM sample

There is an existing sample code for XPCOM component 
whose interface is **nsISample**.
The code is in **MOZ_CEN/xpcom/sample**.
You should see all the code in this dictionary(Look nsISample.idl first).
Take **nsSample.h** as an example here:

<pre>
$ vim MOZ_CEN/xpcom/sample/nsSample.h
</pre>

```cpp
#include "nsISample.h"
#include "mozilla/Attributes.h"

/**
 * SampleImpl is an implementation of the nsISample interface.  In XPCOM,
 * there can be more than one implementation of an given interface.  Class
 * IDs (CIDs) uniquely identify a particular implementation of an interface.
 * Interface IDs (IIDs) uniquely identify an interface.
 *
 * The CID is also a unique number that looks just like an IID
 * and uniquely identifies an implementation
 * {7CB5B7A0-07D7-11d3-BDE2-000064657374}
 */

#define NS_SAMPLE_CID \
{ 0x7cb5b7a0, 0x7d7, 0x11d3, { 0xbd, 0xe2, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }

#define NS_SAMPLE_CONTRACTID "@mozilla.org/sample;1"


class nsSampleImpl MOZ_FINAL : public nsISample
{
public:
  nsSampleImpl();
...
...
}

...
...

```


- Run the **nsISample** XPCOM component

  - If you never built mozilla-central before
<pre>
$ ./mach build or ./mach build/ xpcom/
</pre>

  - Play it in **xpcshell**
<pre>
$ cd obj-YOUR-TARGET-XXXX/dist/bin
$ ./run-mozilla.sh ./xpcshell
</pre>

<pre>
js> const cSample = new Components.Constructor("@mozilla.org/sample;1", "nsISample");
js> var sample = new cSample(); 
js> sample.writeValue("Hello")
Hello initial value
foopy 5
GetValue 8
js> sample.value
initial value
js> sample.poke("nice to see you")
js> sample.value
nice to see you
js> sample.writeValue("yo!man!")
yo!man! nice to see you
foopy 5
GetValue 8
js> sample.value
nice to see you
js> sample.poke("high five");
js> sample.value
high five
js> sample.writeValue("yo!man!");
yo!man! high five
foopy 5
GetValue 8
js> quit()
</pre>
  

## Creating your own XPCOM component

### Making a dictionay for this XPCOM component
<pre>
$ cd MOZ_CEN/xpcom/
$ mkdir sample2
</pre>

### Exposing the dictionary created to mozilla build system
<pre>
$ vim moz.build
</pre>

```
..
..
if CONFIG['OS_ARCH'] == 'WINNT' and CONFIG['MOZ_DEBUG']:
    DIRS += ['windbgdlg']

TEST_DIRS += [
    'tests',
    'sample',
    'sample2',
    'typelib/xpt/tests',
]

#Can not build internal xptcall tests that use symbols which are not exported.
#TEST_DIRS += [
..
..

```

### Writing a IDL file for your XPCOM component
#### Generating a UUID as your XPCOM component ID
<pre>
$ uuidgen
0390037d-9ca2-4d68-b998-4a4245b4d118
</pre>

#### Writing IDL for XPCOM component
<pre>
$ vim nsITest.idl
</pre>

```
#include "nsISupports.idl"
[scriptable, uuid(0390037d-9ca2-4d68-b998-4a4245b4d118)]
interface nsITest : nsISupports
{
    attribute string value;
    void writeValue(in string aPrefix);
    long add(in long a, in long b);
    long sub(in long a, in long b);
    long mul(in long a, in long b);
};

```
  the number in uuid is generated by previous step.

### Generating the interface and implementation template from the IDL

First, you need to write a file for build system:
<pre>
$ vim moz.build
</pre>

```
# XPIDL_SOURCES specifies IDL files. The build system runs the xpidl tool
# on these files to generate C++ headers and .xpt typelib files.
XPIDL_SOURCES += ['nsITest.idl']

# XPIDL_MODULE specifies where header files from this Makefile are installed,
# i.e. dist/include/xpcomsample
XPIDL_MODULE = 'xpcomtest'
```

Then, you can generate the interface and template for your XPCOM component.
<pre>
$ cd MOZ_CEN
$ ./mach build
</pre>


After building, the interface of your XPCOM componenet 
will be in **MOZ_CEN/obj-xxxxx/dist/include** folder.
You will see **nsITest.h** there. 
This file is an interface of your XPCOM componenet, 
and the template of its implementation is in the comment of it.
<pre>
$ vim MOZ_CEN/obj-xxxxx/dist/include/nsITest.h 
</pre>

```cpp
/*
 * DO NOT EDIT.  THIS FILE IS GENERATED FROM ../../../dist/idl/nsITest.idl
 */

#ifndef __gen_nsITest_h__
#define __gen_nsITest_h__


#ifndef __gen_nsISupports_h__
#include "nsISupports.h"
#endif

/* For IDL files that don't want to include root IDL files. */
#ifndef NS_NO_VTABLE
#define NS_NO_VTABLE
#endif

/* starting interface:    nsITest */
#define NS_ITEST_IID_STR "0390037d-9ca2-4d68-b998-4a4245b4d118"

#define NS_ITEST_IID \
  {0x0390037d, 0x9ca2, 0x4d68, \
    { 0xb9, 0x98, 0x4a, 0x42, 0x45, 0xb4, 0xd1, 0x18 }}

class NS_NO_VTABLE nsITest : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ITEST_IID)

  /* attribute string value; */
  NS_IMETHOD GetValue(char * *aValue) = 0;
  NS_IMETHOD SetValue(const char * aValue) = 0;

  /* void writeValue (in string aPrefix); */
  NS_IMETHOD WriteValue(const char * aPrefix) = 0;

  /* long add (in long a, in long b); */
  NS_IMETHOD Add(int32_t a, int32_t b, int32_t *_retval) = 0;

  /* long sub (in long a, in long b); */
  NS_IMETHOD Sub(int32_t a, int32_t b, int32_t *_retval) = 0;

  /* long mul (in long a, in long b); */
  NS_IMETHOD Mul(int32_t a, int32_t b, int32_t *_retval) = 0;

};

...
...

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsTest : public nsITest
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSITEST

  nsTest();

private:
  ~nsTest();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS(nsTest, nsITest)

nsTest::nsTest()
{
  /* member initializers and constructor code */
}

nsTest::~nsTest()
{
  /* destructor code */
}

/* attribute string value; */
NS_IMETHODIMP nsTest::GetValue(char * *aValue)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsTest::SetValue(const char * aValue)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void writeValue (in string aPrefix); */
NS_IMETHODIMP nsTest::WriteValue(const char * aPrefix)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long add (in long a, in long b); */
NS_IMETHODIMP nsTest::Add(int32_t a, int32_t b, int32_t *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long sub (in long a, in long b); */
NS_IMETHODIMP nsTest::Sub(int32_t a, int32_t b, int32_t *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long mul (in long a, in long b); */
NS_IMETHODIMP nsTest::Mul(int32_t a, int32_t b, int32_t *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* End of implementation class template. */
#endif

#endif /* __gen_nsITest_h__ */
```

The template of .h and .cpp is in comment 
*Header file* and *Implementation file*.


### Implementing your XPCOM component from the template

Creating a .h file in **sample2** folder and completing your code from
the template /* Header file*/ in nsITest.h
<pre>
$ vim nsTest.h 
</pre>

```cpp
#ifndef nsTest_h
#define nsTest_h

/**
 * This file is the header of an implementation nsTest of the nsITest interface.
 */

#include "nsITest.h"
#include "mozilla/Attributes.h"

/**
 * TestImpl is an implementation of the nsITest interface.  In XPCOM,
 * there can be more than one implementation of an given interface.  Class
 * IDs (CIDs) uniquely identify a particular implementation of an interface.
 * Interface IDs (IIDs) uniquely identify an interface.
 *
 * The CID is also a unique number that looks just like an IID
 * and uniquely identifies an implementation
 * {0390037d-9ca2-4d68-b998-4a4245b4d118}
 */

#define NS_TEST_CID \
{ 0x0390037d, 0x9ca2, 0x4d68, { 0xb9, 0x98, 0x4a, 0x42, 0x45, 0xb4, 0xd1, 0x18 } }

#define NS_TEST_CONTRACTID "@mozilla.org/test;1"


class nsTest : public nsITest
{
public:
  /**
   * This macro expands into a declaration of the nsISupports interface.
   * Every XPCOM component needs to implement nsISupports, as it acts
   * as the gateway to other interfaces this component implements.  You
   * could manually declare QueryInterface, AddRef, and Release instead
   * of using this macro, but why?
   */
  // nsISupports interface
  NS_DECL_ISUPPORTS

  /**
   * This macro is defined in the nsITest.h file, and is generated
   * automatically by the xpidl compiler.  It expands to
   * declarations of all of the methods required to implement the
   * interface.  xpidl will generate a NS_DECL_[INTERFACENAME] macro
   * for each interface that it processes.
   *
   * The methods of nsITest are discussed individually below, but
   * commented out (because this macro already defines them.)
   */
  NS_DECL_NSITEST

 /**
   * The following is an explanation of how the interface header
   * file expands to for a c++ implementation. NS_DELC_NSITEST
   * takes care of defining the right c++ implementation.
   *
   * The following if provided for more understanding.
   *
   * NS_IMETHOD expands to the standard XPCOM return type.  XPCOM methods
   * should never return any other type.  The return value is used
   * behind the scenes by the XPConnect runtime to figure out if the call
   * failed in any way.
   * These methods were generated by "attribute string Value" in
   * nsITest.idl.  When reflected into JavaScript, XPCOM will use these
   * calls as Getter/Setter ops, so that they can be called transparently
   * as "test.Value='foo';" and "var val = test.Value"
   */
  /* NS_IMETHOD GetValue(char** aValue); */
  /* NS_IMETHOD SetValue(char* aValue); */

  /**
   * The const came from the "in" specifier in nsITest.idl.  "in"
   * specifies that the value of this parameter is used only for input,
   * this method is not allowed to modify the contents of the buffer.
   */
  /* NS_IMETHOD WriteValue(const char* aPrefix); */

  /**
   * nsITest.idl specifies all of its string types as string, instead
   * of wstring (wide string), the Unicode type.  If the world were a
   * perfect place, all normal strings in XPCOM interfaces would be unicode.
   * If this type had been specified as wstring, it would appear as
   * char16_t * in C++, which is the NSPR type for unicode characters.
   */
  /* NS_IMETHOD Add(int32_t a, int32_t b, int32_t *_retval); */
  /* NS_IMETHOD Sub(int32_t a, int32_t b, int32_t *_retval); */
  /* NS_IMETHOD Mul(int32_t a, int32_t b, int32_t *_retval); */


  nsTest();

private:
  ~nsTest();

  char* mValue;

protected:
  /* additional members */
};

#endif 
```

Next, writing the .cpp file

<pre>
$ vim nsTest.cpp 
</pre>

```cpp
/**
 * This file contains an implementation nsTest of the interface nsISample.
 */
#include <stdio.h>

#include "nsTest.h"
#include "nsMemory.h"

#include "nsEmbedString.h"
#include "nsIClassInfoImpl.h"
////////////////////////////////////////////////////////////////////////

nsTest::nsTest() : mValue(nullptr)
{
  mValue = (char*)nsMemory::Clone("hello world", 12);
  //12 = strlen("hello world") + strlen('\0') = 11 + 1
}

nsTest::~nsTest()
{
  if (mValue) {
    nsMemory::Free(mValue);
  }
}


/**
 * NS_IMPL_ISUPPORTS expands to a simple implementation of the nsISupports
 * interface.  This includes a proper implementation of AddRef, Release,
 * and QueryInterface.  If this class supported more interfaces than just
 * nsISupports,
 * you could use NS_IMPL_ADDREF() and NS_IMPL_RELEASE() to take care of the
 * simple stuff, but you would have to create QueryInterface on your own.
 * nsSampleFactory.cpp is an example of this approach.
 * Notice that the second parameter to the macro is name of the interface, and
 * NOT the #defined IID.
 *
 * The _CI variant adds support for nsIClassInfo, which permits introspection
 * and interface flattening.
 */
NS_IMPL_CLASSINFO(nsTest, nullptr, 0, NS_TEST_CID)
NS_IMPL_ISUPPORTS_CI(nsTest, nsITest)


/**
 * Notice that in the protoype for this function, the NS_IMETHOD macro was
 * used to declare the return type.  For the implementation, the return
 * type is declared by NS_IMETHODIMP
 */
NS_IMETHODIMP
nsTest::GetValue(char** aValue)
{
  NS_PRECONDITION(aValue != nullptr, "null ptr");
  if (!aValue) {
    return NS_ERROR_NULL_POINTER;
  }

  if (mValue) {
    /**
     * GetValue's job is to return data known by an instance of
     * nsSample to the outside world.  If we  were to simply return
     * a pointer to data owned by this instance, and the client were to
     * free it, bad things would surely follow.
     * On the other hand, if we create a new copy of the data for our
     * client, and it turns out that client is implemented in JavaScript,
     * there would be no way to free the buffer.  The solution to the
     * buffer ownership problem is the nsMemory singleton.  Any buffer
     * returned by an XPCOM method should be allocated by the nsMemory.
     * This convention lets things like JavaScript reflection do their
     * job, and simplifies the way C++ clients deal with returned buffers.
     */
    *aValue = (char*)nsMemory::Clone(mValue, strlen(mValue) + 1);
    if (!*aValue) {
      return NS_ERROR_NULL_POINTER;
    }
  } else {
    *aValue = nullptr;
  }
  return NS_OK;
}

NS_IMETHODIMP
nsTest::SetValue(const char* aValue)
{
  NS_PRECONDITION(aValue != nullptr, "null ptr");
  if (!aValue) {
    return NS_ERROR_NULL_POINTER;
  }

  if (mValue) {
    nsMemory::Free(mValue);
  }

  /**
   * Another buffer passing convention is that buffers passed INTO your
   * object ARE NOT YOURS.  Keep your hands off them, unless they are
   * declared "inout".  If you want to keep the value for posterity,
   * you will have to make a copy of it.
   */
  mValue = (char*)nsMemory::Clone(aValue, strlen(aValue) + 1);
  return NS_OK;
}

/* long add (in long a, in long b); */
NS_IMETHODIMP
nsTest::Add(int32_t a, int32_t b, int32_t *_retval)
{
    *_retval = a + b;
    return NS_OK;
}


/* long sub (in long a, in long b); */
NS_IMETHODIMP
nsTest::Sub(int32_t a, int32_t b, int32_t *_retval)
{
    *_retval = a - b;
    return NS_OK;
}


/* long mul (in long a, in long b); */
NS_IMETHODIMP
nsTest::Mul(int32_t a, int32_t b, int32_t *_retval)
{
    *_retval = a * b;
    return NS_OK;
}


static void
GetStringValue(nsACString& aValue)
{
  NS_CStringSetData(aValue, "GetValue");
}


/* void writeValue (in string aPrefix); */
NS_IMETHODIMP
nsTest::WriteValue(const char* aPrefix)
{
  NS_PRECONDITION(aPrefix != nullptr, "null ptr");
  if (!aPrefix) {
    return NS_ERROR_NULL_POINTER;
  }

  printf("%s %s\n", aPrefix, mValue);

  // This next part illustrates the nsEmbedString:
  nsEmbedString foopy;
  foopy.Append(char16_t('f'));
  foopy.Append(char16_t('o'));
  foopy.Append(char16_t('o'));
  foopy.Append(char16_t('p'));
  foopy.Append(char16_t('y'));

  const char16_t* f = foopy.get();
  uint32_t l = foopy.Length();
  printf("%c%c%c%c%c %d\n",
         char(f[0]), char(f[1]), char(f[2]), char(f[3]), char(f[4]), l);

  nsEmbedCString foopy2;
  GetStringValue(foopy2);

  //foopy2.AppendLiteral("foopy");
  const char* f2 = foopy2.get();
  uint32_t l2 = foopy2.Length();

  printf("%s %d\n", f2, l2);

  return NS_OK;
}
```

### Module file

<pre>
$ vim nsTestModule.cpp 
</pre>

```cpp
#include "mozilla/ModuleUtils.h"
#include "nsIClassInfoImpl.h"

#include "nsTest.h"

////////////////////////////////////////////////////////////////////////
// With the below sample, you can define an implementation glue
// that talks with xpcom for creation of component nsTest
// that implement the interface nsITest. This can be extended for
// any number of components.
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// Define the contructor function for the object nsTest
//
// What this does is defines a function nsTestConstructor which we
// will specific in the nsModuleComponentInfo table. This function will
// be used by the generic factory to create an instance of nsTest.
//
// NOTE: This creates an instance of nsTest by using the default
//         constructor nsTest::nsTest()
//
NS_GENERIC_FACTORY_CONSTRUCTOR(nsTest)

// The following line defines a kNS_TEST_CID CID variable.
NS_DEFINE_NAMED_CID(NS_TEST_CID);

// Build a table of ClassIDs (CIDs) which are implemented by this module. CIDs
// should be completely unique UUIDs.
// each entry has the form { CID, service, factoryproc, constructorproc }
// where factoryproc is usually nullptr.
static const mozilla::Module::CIDEntry kTestCIDs[] = {
  { &kNS_TEST_CID, false, nullptr, nsTestConstructor },
  { nullptr }
};

// Build a table which maps contract IDs to CIDs.
// A contract is a string which identifies a particular set of functionality. In some
// cases an extension component may override the contract ID of a builtin gecko component
// to modify or extend functionality.
static const mozilla::Module::ContractIDEntry kTestContracts[] = {
  { NS_TEST_CONTRACTID, &kNS_TEST_CID },
  { nullptr }
};

// Category entries are category/key/value triples which can be used
// to register contract ID as content handlers or to observe certain
// notifications. Most modules do not need to register any category
// entries: this is just a sample of how you'd do it.
// @see nsICategoryManager for information on retrieving category data.
static const mozilla::Module::CategoryEntry kTestCategories[] = {
  { "my-category", "my-key", NS_TEST_CONTRACTID },
  { nullptr }
};

static const mozilla::Module kTestModule = {
  mozilla::Module::kVersion,
  kTestCIDs,
  kTestContracts,
  kTestCategories
};

// The following line implements the one-and-only "NSModule" symbol exported from this
// shared library.
NSMODULE_DEFN(nsTestModule) = &kTestModule;

// The following line implements the one-and-only "NSGetModule" symbol
// for compatibility with mozilla 1.9.2. You should only use this
// if you need a binary which is backwards-compatible and if you use
// interfaces carefully across multiple versions.
NS_IMPL_MOZILLA192_NSGETMODULE(&kTestModule)
```

### Javascript file

<pre>
$ uuidgen
217f9cb2-7496-41ea-aa7c-b4270e1ad338
</pre>

<pre>
$ vim nsTest.js 
</pre>

```javascript
Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");

/**
 * We set up a sample component. The constructor is empty, all the interesting
 * stuff goes in the prototype.
 */
function myTest() { }

myTest.prototype = {
    /**
     * .classID is required for generateNSGetFactory to work correctly.
     * Make sure this CID matches the "component" in your .manifest file.
     */
    classID: Components.ID("{217f9cb2-7496-41ea-aa7c-b4270e1ad338}"),

    /**
     * .classDescription and .contractID are only used for
     * backwards compatibility with Gecko 1.9.2 and
     * XPCOMUtils.generateNSGetModule.
     */
    classDescription: "nsTest: JS version", // any human-readable string
    contractID: "@mozilla.org/jstest;1",

    /**
     * List all the interfaces your component supports.
     * @note nsISupports is generated automatically; you don't need to list it.
     */
    QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsITest]),

    /*
     * get and set are new Magic in JS1.5, borrowing the intent -- if not
     * the exact syntax -- from the JS2 design.  They define accessors for
     * properties on the JS object, follow the expected rules for prototype
     * delegation, and make a mean cup of coffee.
     */
    get value()       { return this.val; },
    set value(newval) { return this.val = newval; },

    writeValue: function (aPrefix) {
        debug("myTest::writeValue => " + aPrefix + this.val + "\n");
    },
    add: function (a, b) { return a + b; },
    sub: function (a, b) { return a - b; },
    mul: function (a, b) { return a * b; },

    val: "<default value>"
};

/**
 * XPCOMUtils.generateNSGetFactory was introduced in Mozilla 2 (Firefox 4).
 * XPCOMUtils.generateNSGetModule is for Mozilla 1.9.2 (Firefox 3.6).
 */
if (XPCOMUtils.generateNSGetFactory)
    this.NSGetFactory = XPCOMUtils.generateNSGetFactory([myTest]);
else
    var NSGetModule = XPCOMUtils.generateNSGetModule([myTest]);
```

### manifest file

<pre>
$ vim nsTest.manifest
</pre>

```
component 217f9cb2-7496-41ea-aa7c-b4270e1ad338 nsTest.js
contract @mozilla.org/jstest;1 217f9cb2-7496-41ea-aa7c-b4270e1ad338
```

### xpconnect test html
<pre>
$ vim xpconnect-test.html
</pre>

```html
```

### Building your XPCOM component

<pre>
$ vim moz.build
</pre>

```
# If you're copying from this file, you'll likely need to replace
# TEST_DIRS with DIRS.
#TEST_DIRS += ['program']

# XPIDL_SOURCES specifies IDL files. The build system runs the xpidl tool
# on these files to generate C++ headers and .xpt typelib files.
XPIDL_SOURCES += ['nsITest.idl']

# XPIDL_MODULE specifies where header files from this Makefile are installed,
# i.e. dist/include/xpcomsample
XPIDL_MODULE = 'xpcomtest'

# CPP_SOURCES specifies C++ files to be built into a library.
UNIFIED_SOURCES += [
    'nsTest.cpp',
    'nsTestModule.cpp',
]

# EXTRA_COMPONENTS installs components written JavaScript to
# dist/bin/components
EXTRA_COMPONENTS += [
    'nsTest.js',
    'nsTest.manifest',
]

# XPCOMBinaryComponent names the library generated by this makefile,
# i.e. dist/bin/components/libxpcomsample.so
XPCOMBinaryComponent('xpcomtest')

RESOURCE_FILES.samples += [
    'xpconnect-test.html',
]

# Need to link with CoreFoundation on Mac
if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
    OS_LIBS += CONFIG['TK_LIBS']
```

<pre>
$ cd MOZ_CEN
$ ./mach build
</pre>


### Testing your XPCOM component in **xpcshell**

<pre>
$ cd obj-YOUR-TARGET-XXXX/dist/bin
$ ./run-mozilla.sh ./xpcshell
</pre>

<pre>
js> const cTest = new Components.Constructor("@mozilla.org/test;1","nsITest");
js> var test = new cTest();
js> test.value
hello world
js> test.value="Mama"
Mama
js> test.value   
Mama
js> test.writeValue("Call my")
Call my Mama
foopy 5
GetValue 8
js> test.value
Mama
js> test.value="papa";
papa
js> test.writeValue("I need to call my")
I need to call my papa
foopy 5
GetValue 8
js> test.add(5,23)
28
js> test.sub(5,23)
-18
js> test.mul(5,23)
115
js> test.mul(test.add(5,23), test.sub(5,23));
-504
js> quit()
</pre>


## Reference
<a name="XPCOM" title="Creating XPCOM components" target="_blank" href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Creating_components">[1] Creating XPCOM components</a>

<a title="Creating a C++ XPCOM component" target="_blank" href="http://www.iosart.com/firefox/xpcom/">[2] Creating a C++ XPCOM component</a>

<a title="Create and implement an XPCOM component for the Firefox browser" target="_blank" href="http://www.ibm.com/developerworks/library/os-xpcomfirefox/">[3] Create and implement an XPCOM component for the Firefox browser</a>


## Manuscript
<a title="Google Doc" target="_blank" href="https://docs.google.com/a/mozilla.com/document/d/1rlAnNbVYUnI6PMWjn4eTB_As5tPfYObco9lDNkf8N6E/edit?usp=sharing">click here</a>
